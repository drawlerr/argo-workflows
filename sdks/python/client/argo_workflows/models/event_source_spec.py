# coding: utf-8

"""
    Argo Workflows API

    Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argo-workflows.readthedocs.io/en/latest/

    The version of the OpenAPI document: VERSION
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictInt, StrictStr
from pydantic import Field
from argo_workflows.models.amqp_event_source import AMQPEventSource
from argo_workflows.models.azure_events_hub_event_source import AzureEventsHubEventSource
from argo_workflows.models.bitbucket_event_source import BitbucketEventSource
from argo_workflows.models.bitbucket_server_event_source import BitbucketServerEventSource
from argo_workflows.models.calendar_event_source import CalendarEventSource
from argo_workflows.models.emitter_event_source import EmitterEventSource
from argo_workflows.models.file_event_source import FileEventSource
from argo_workflows.models.generic_event_source import GenericEventSource
from argo_workflows.models.github_event_source import GithubEventSource
from argo_workflows.models.gitlab_event_source import GitlabEventSource
from argo_workflows.models.hdfs_event_source import HDFSEventSource
from argo_workflows.models.kafka_event_source import KafkaEventSource
from argo_workflows.models.mqtt_event_source import MQTTEventSource
from argo_workflows.models.nats_events_source import NATSEventsSource
from argo_workflows.models.nsq_event_source import NSQEventSource
from argo_workflows.models.pub_sub_event_source import PubSubEventSource
from argo_workflows.models.pulsar_event_source import PulsarEventSource
from argo_workflows.models.redis_event_source import RedisEventSource
from argo_workflows.models.redis_stream_event_source import RedisStreamEventSource
from argo_workflows.models.resource_event_source import ResourceEventSource
from argo_workflows.models.s3_artifact import S3Artifact
from argo_workflows.models.service import Service
from argo_workflows.models.slack_event_source import SlackEventSource
from argo_workflows.models.sns_event_source import SNSEventSource
from argo_workflows.models.sqs_event_source import SQSEventSource
from argo_workflows.models.storage_grid_event_source import StorageGridEventSource
from argo_workflows.models.stripe_event_source import StripeEventSource
from argo_workflows.models.template import Template
from argo_workflows.models.webhook_event_source import WebhookEventSource
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class EventSourceSpec(BaseModel):
    """
    EventSourceSpec
    """ # noqa: E501
    amqp: Optional[Dict[str, AMQPEventSource]] = None
    azure_events_hub: Optional[Dict[str, AzureEventsHubEventSource]] = Field(default=None, alias="azureEventsHub")
    bitbucket: Optional[Dict[str, BitbucketEventSource]] = None
    bitbucketserver: Optional[Dict[str, BitbucketServerEventSource]] = None
    calendar: Optional[Dict[str, CalendarEventSource]] = None
    emitter: Optional[Dict[str, EmitterEventSource]] = None
    event_bus_name: Optional[StrictStr] = Field(default=None, alias="eventBusName")
    file: Optional[Dict[str, FileEventSource]] = None
    generic: Optional[Dict[str, GenericEventSource]] = None
    github: Optional[Dict[str, GithubEventSource]] = None
    gitlab: Optional[Dict[str, GitlabEventSource]] = None
    hdfs: Optional[Dict[str, HDFSEventSource]] = None
    kafka: Optional[Dict[str, KafkaEventSource]] = None
    minio: Optional[Dict[str, S3Artifact]] = None
    mqtt: Optional[Dict[str, MQTTEventSource]] = None
    nats: Optional[Dict[str, NATSEventsSource]] = None
    nsq: Optional[Dict[str, NSQEventSource]] = None
    pub_sub: Optional[Dict[str, PubSubEventSource]] = Field(default=None, alias="pubSub")
    pulsar: Optional[Dict[str, PulsarEventSource]] = None
    redis: Optional[Dict[str, RedisEventSource]] = None
    redis_stream: Optional[Dict[str, RedisStreamEventSource]] = Field(default=None, alias="redisStream")
    replicas: Optional[StrictInt] = None
    resource: Optional[Dict[str, ResourceEventSource]] = None
    service: Optional[Service] = None
    slack: Optional[Dict[str, SlackEventSource]] = None
    sns: Optional[Dict[str, SNSEventSource]] = None
    sqs: Optional[Dict[str, SQSEventSource]] = None
    storage_grid: Optional[Dict[str, StorageGridEventSource]] = Field(default=None, alias="storageGrid")
    stripe: Optional[Dict[str, StripeEventSource]] = None
    template: Optional[Template] = None
    webhook: Optional[Dict[str, WebhookEventSource]] = None
    __properties: ClassVar[List[str]] = ["amqp", "azureEventsHub", "bitbucket", "bitbucketserver", "calendar", "emitter", "eventBusName", "file", "generic", "github", "gitlab", "hdfs", "kafka", "minio", "mqtt", "nats", "nsq", "pubSub", "pulsar", "redis", "redisStream", "replicas", "resource", "service", "slack", "sns", "sqs", "storageGrid", "stripe", "template", "webhook"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of EventSourceSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in amqp (dict)
        _field_dict = {}
        if self.amqp:
            for _key in self.amqp:
                if self.amqp[_key]:
                    _field_dict[_key] = self.amqp[_key].to_dict()
            _dict['amqp'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in azure_events_hub (dict)
        _field_dict = {}
        if self.azure_events_hub:
            for _key in self.azure_events_hub:
                if self.azure_events_hub[_key]:
                    _field_dict[_key] = self.azure_events_hub[_key].to_dict()
            _dict['azureEventsHub'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in bitbucket (dict)
        _field_dict = {}
        if self.bitbucket:
            for _key in self.bitbucket:
                if self.bitbucket[_key]:
                    _field_dict[_key] = self.bitbucket[_key].to_dict()
            _dict['bitbucket'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in bitbucketserver (dict)
        _field_dict = {}
        if self.bitbucketserver:
            for _key in self.bitbucketserver:
                if self.bitbucketserver[_key]:
                    _field_dict[_key] = self.bitbucketserver[_key].to_dict()
            _dict['bitbucketserver'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in calendar (dict)
        _field_dict = {}
        if self.calendar:
            for _key in self.calendar:
                if self.calendar[_key]:
                    _field_dict[_key] = self.calendar[_key].to_dict()
            _dict['calendar'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in emitter (dict)
        _field_dict = {}
        if self.emitter:
            for _key in self.emitter:
                if self.emitter[_key]:
                    _field_dict[_key] = self.emitter[_key].to_dict()
            _dict['emitter'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in file (dict)
        _field_dict = {}
        if self.file:
            for _key in self.file:
                if self.file[_key]:
                    _field_dict[_key] = self.file[_key].to_dict()
            _dict['file'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in generic (dict)
        _field_dict = {}
        if self.generic:
            for _key in self.generic:
                if self.generic[_key]:
                    _field_dict[_key] = self.generic[_key].to_dict()
            _dict['generic'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in github (dict)
        _field_dict = {}
        if self.github:
            for _key in self.github:
                if self.github[_key]:
                    _field_dict[_key] = self.github[_key].to_dict()
            _dict['github'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in gitlab (dict)
        _field_dict = {}
        if self.gitlab:
            for _key in self.gitlab:
                if self.gitlab[_key]:
                    _field_dict[_key] = self.gitlab[_key].to_dict()
            _dict['gitlab'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in hdfs (dict)
        _field_dict = {}
        if self.hdfs:
            for _key in self.hdfs:
                if self.hdfs[_key]:
                    _field_dict[_key] = self.hdfs[_key].to_dict()
            _dict['hdfs'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in kafka (dict)
        _field_dict = {}
        if self.kafka:
            for _key in self.kafka:
                if self.kafka[_key]:
                    _field_dict[_key] = self.kafka[_key].to_dict()
            _dict['kafka'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in minio (dict)
        _field_dict = {}
        if self.minio:
            for _key in self.minio:
                if self.minio[_key]:
                    _field_dict[_key] = self.minio[_key].to_dict()
            _dict['minio'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in mqtt (dict)
        _field_dict = {}
        if self.mqtt:
            for _key in self.mqtt:
                if self.mqtt[_key]:
                    _field_dict[_key] = self.mqtt[_key].to_dict()
            _dict['mqtt'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in nats (dict)
        _field_dict = {}
        if self.nats:
            for _key in self.nats:
                if self.nats[_key]:
                    _field_dict[_key] = self.nats[_key].to_dict()
            _dict['nats'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in nsq (dict)
        _field_dict = {}
        if self.nsq:
            for _key in self.nsq:
                if self.nsq[_key]:
                    _field_dict[_key] = self.nsq[_key].to_dict()
            _dict['nsq'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in pub_sub (dict)
        _field_dict = {}
        if self.pub_sub:
            for _key in self.pub_sub:
                if self.pub_sub[_key]:
                    _field_dict[_key] = self.pub_sub[_key].to_dict()
            _dict['pubSub'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in pulsar (dict)
        _field_dict = {}
        if self.pulsar:
            for _key in self.pulsar:
                if self.pulsar[_key]:
                    _field_dict[_key] = self.pulsar[_key].to_dict()
            _dict['pulsar'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in redis (dict)
        _field_dict = {}
        if self.redis:
            for _key in self.redis:
                if self.redis[_key]:
                    _field_dict[_key] = self.redis[_key].to_dict()
            _dict['redis'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in redis_stream (dict)
        _field_dict = {}
        if self.redis_stream:
            for _key in self.redis_stream:
                if self.redis_stream[_key]:
                    _field_dict[_key] = self.redis_stream[_key].to_dict()
            _dict['redisStream'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in resource (dict)
        _field_dict = {}
        if self.resource:
            for _key in self.resource:
                if self.resource[_key]:
                    _field_dict[_key] = self.resource[_key].to_dict()
            _dict['resource'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of service
        if self.service:
            _dict['service'] = self.service.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in slack (dict)
        _field_dict = {}
        if self.slack:
            for _key in self.slack:
                if self.slack[_key]:
                    _field_dict[_key] = self.slack[_key].to_dict()
            _dict['slack'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in sns (dict)
        _field_dict = {}
        if self.sns:
            for _key in self.sns:
                if self.sns[_key]:
                    _field_dict[_key] = self.sns[_key].to_dict()
            _dict['sns'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in sqs (dict)
        _field_dict = {}
        if self.sqs:
            for _key in self.sqs:
                if self.sqs[_key]:
                    _field_dict[_key] = self.sqs[_key].to_dict()
            _dict['sqs'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in storage_grid (dict)
        _field_dict = {}
        if self.storage_grid:
            for _key in self.storage_grid:
                if self.storage_grid[_key]:
                    _field_dict[_key] = self.storage_grid[_key].to_dict()
            _dict['storageGrid'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in stripe (dict)
        _field_dict = {}
        if self.stripe:
            for _key in self.stripe:
                if self.stripe[_key]:
                    _field_dict[_key] = self.stripe[_key].to_dict()
            _dict['stripe'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of template
        if self.template:
            _dict['template'] = self.template.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in webhook (dict)
        _field_dict = {}
        if self.webhook:
            for _key in self.webhook:
                if self.webhook[_key]:
                    _field_dict[_key] = self.webhook[_key].to_dict()
            _dict['webhook'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of EventSourceSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "amqp": dict(
                (_k, AMQPEventSource.from_dict(_v))
                for _k, _v in obj.get("amqp").items()
            )
            if obj.get("amqp") is not None
            else None,
            "azureEventsHub": dict(
                (_k, AzureEventsHubEventSource.from_dict(_v))
                for _k, _v in obj.get("azureEventsHub").items()
            )
            if obj.get("azureEventsHub") is not None
            else None,
            "bitbucket": dict(
                (_k, BitbucketEventSource.from_dict(_v))
                for _k, _v in obj.get("bitbucket").items()
            )
            if obj.get("bitbucket") is not None
            else None,
            "bitbucketserver": dict(
                (_k, BitbucketServerEventSource.from_dict(_v))
                for _k, _v in obj.get("bitbucketserver").items()
            )
            if obj.get("bitbucketserver") is not None
            else None,
            "calendar": dict(
                (_k, CalendarEventSource.from_dict(_v))
                for _k, _v in obj.get("calendar").items()
            )
            if obj.get("calendar") is not None
            else None,
            "emitter": dict(
                (_k, EmitterEventSource.from_dict(_v))
                for _k, _v in obj.get("emitter").items()
            )
            if obj.get("emitter") is not None
            else None,
            "eventBusName": obj.get("eventBusName"),
            "file": dict(
                (_k, FileEventSource.from_dict(_v))
                for _k, _v in obj.get("file").items()
            )
            if obj.get("file") is not None
            else None,
            "generic": dict(
                (_k, GenericEventSource.from_dict(_v))
                for _k, _v in obj.get("generic").items()
            )
            if obj.get("generic") is not None
            else None,
            "github": dict(
                (_k, GithubEventSource.from_dict(_v))
                for _k, _v in obj.get("github").items()
            )
            if obj.get("github") is not None
            else None,
            "gitlab": dict(
                (_k, GitlabEventSource.from_dict(_v))
                for _k, _v in obj.get("gitlab").items()
            )
            if obj.get("gitlab") is not None
            else None,
            "hdfs": dict(
                (_k, HDFSEventSource.from_dict(_v))
                for _k, _v in obj.get("hdfs").items()
            )
            if obj.get("hdfs") is not None
            else None,
            "kafka": dict(
                (_k, KafkaEventSource.from_dict(_v))
                for _k, _v in obj.get("kafka").items()
            )
            if obj.get("kafka") is not None
            else None,
            "minio": dict(
                (_k, S3Artifact.from_dict(_v))
                for _k, _v in obj.get("minio").items()
            )
            if obj.get("minio") is not None
            else None,
            "mqtt": dict(
                (_k, MQTTEventSource.from_dict(_v))
                for _k, _v in obj.get("mqtt").items()
            )
            if obj.get("mqtt") is not None
            else None,
            "nats": dict(
                (_k, NATSEventsSource.from_dict(_v))
                for _k, _v in obj.get("nats").items()
            )
            if obj.get("nats") is not None
            else None,
            "nsq": dict(
                (_k, NSQEventSource.from_dict(_v))
                for _k, _v in obj.get("nsq").items()
            )
            if obj.get("nsq") is not None
            else None,
            "pubSub": dict(
                (_k, PubSubEventSource.from_dict(_v))
                for _k, _v in obj.get("pubSub").items()
            )
            if obj.get("pubSub") is not None
            else None,
            "pulsar": dict(
                (_k, PulsarEventSource.from_dict(_v))
                for _k, _v in obj.get("pulsar").items()
            )
            if obj.get("pulsar") is not None
            else None,
            "redis": dict(
                (_k, RedisEventSource.from_dict(_v))
                for _k, _v in obj.get("redis").items()
            )
            if obj.get("redis") is not None
            else None,
            "redisStream": dict(
                (_k, RedisStreamEventSource.from_dict(_v))
                for _k, _v in obj.get("redisStream").items()
            )
            if obj.get("redisStream") is not None
            else None,
            "replicas": obj.get("replicas"),
            "resource": dict(
                (_k, ResourceEventSource.from_dict(_v))
                for _k, _v in obj.get("resource").items()
            )
            if obj.get("resource") is not None
            else None,
            "service": Service.from_dict(obj.get("service")) if obj.get("service") is not None else None,
            "slack": dict(
                (_k, SlackEventSource.from_dict(_v))
                for _k, _v in obj.get("slack").items()
            )
            if obj.get("slack") is not None
            else None,
            "sns": dict(
                (_k, SNSEventSource.from_dict(_v))
                for _k, _v in obj.get("sns").items()
            )
            if obj.get("sns") is not None
            else None,
            "sqs": dict(
                (_k, SQSEventSource.from_dict(_v))
                for _k, _v in obj.get("sqs").items()
            )
            if obj.get("sqs") is not None
            else None,
            "storageGrid": dict(
                (_k, StorageGridEventSource.from_dict(_v))
                for _k, _v in obj.get("storageGrid").items()
            )
            if obj.get("storageGrid") is not None
            else None,
            "stripe": dict(
                (_k, StripeEventSource.from_dict(_v))
                for _k, _v in obj.get("stripe").items()
            )
            if obj.get("stripe") is not None
            else None,
            "template": Template.from_dict(obj.get("template")) if obj.get("template") is not None else None,
            "webhook": dict(
                (_k, WebhookEventSource.from_dict(_v))
                for _k, _v in obj.get("webhook").items()
            )
            if obj.get("webhook") is not None
            else None
        })
        return _obj


